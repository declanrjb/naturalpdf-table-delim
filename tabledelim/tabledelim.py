import natural_pdf
from natural_pdf import PDF
import pandas as pd
import re
import math

__all__ = ['table_delim', 'find_by_regex', 'delineate_regions', 'slice_fitting_elem', 'intersection']

# accepts left, top, right, bottom
def sort_elems_by_dim(elems, dim):
    sorted_elems = []

    bb_ind = {
        'left': 0,
        'top': 1,
        'right': 2,
        'bottom': 3
    }[dim]

    seen_positions = []

    while len(elems) > 0:
        cand_min = math.inf
        cand_elem = None
        for elem in elems:
            if elem.bbox[bb_ind] <= cand_min:
                cand_min = elem.bbox[bb_ind]
                cand_elem = elem
        # remove duplicates generated by OCR
        if cand_elem.bbox[bb_ind] not in seen_positions:
            seen_positions.append(cand_elem.bbox[bb_ind])
            sorted_elems.append(cand_elem)
        elems.remove(cand_elem)
    return sorted_elems

def intersection(page, regions):
    return page.create_region(
        max([region.bbox[0] for region in regions]),
        max([region.bbox[1] for region in regions]),
        min([region.bbox[2] for region in regions]),
        min([region.bbox[3] for region in regions])
    )

def find_by_regex(region, pattern):
    elems = region.find_all('text')
    return [elem for elem in elems if re.match(pattern, elem.text) is not None]

def delineate_regions(page, bbox, delims, direction='row'):
    if direction == 'row':
        return [page.create_region(
            bbox['left'],
            delims[i].bbox[1],
            bbox['right'],
            delims[i+1].bbox[1] - 1 if i < (len(delims) - 1) else delims[i].bbox[3]
        ) for i in range(0, len(delims))]
    elif direction == 'col':
        return [page.create_region(
            delims[i].bbox[0],
            bbox['top'],
            delims[i+1].bbox[0] - 1 if i < (len(delims) - 1) else delims[i].bbox[2],
            bbox['bottom']
        ) for i in range(0, len(delims))]
    else:
        raise ValueError("Please pass exactly one of 'row' or 'col' to param direction.")

def slice_fitting_elem(page, elem, direction='row'):

    if type(elem) == str:
        elem = page.find(elem)

    if direction == 'row':
        return page.create_region(
            0,
            elem.bbox[1],
            page.width,
            elem.bbox[3]
        )
    elif direction == 'col':
        return page.create_region(
            elem.bbox[0],
            0,
            elem.bbox[2],
            page.height
        )
    else:
        raise ValueError('Please pass exactly one of row, col to param direction.')

# detect and correct new line folds
def df_expand(df):
    i = 0
    expansions = []
    while i < len(df):
        if '\n' in df.iloc[i][0]:
            expanded_data = unfold_row(df.iloc[i])
            df = df.drop(i).reset_index(drop=True)
            expansions.append(expanded_data)
        else:
            i += 1
    df = pd.concat([df] + expansions)
    return df

def unfold_row(row):
    expanded_rows = list([row[i].split('\n') for i in range(0, len(row))])
    expansion_bar = max([len(row) for row in expanded_rows])
    for i in range(0, len(expanded_rows)):
        if len(expanded_rows[i]) == 1:
            expanded_rows[i] = [expanded_rows[i][0]] * expansion_bar

    return pd.DataFrame(expanded_rows).transpose()

def table_delim(page, rows, cols, bbox={}, try_unfold=True):
    
    default_bbox = {
        'left': 0,
        'top': 0,
        'right': page.width,
        'bottom': page.height
    } | bbox

    table_region = page.create_region(
            default_bbox['left'],
            default_bbox['top'],
            default_bbox['right'],
            default_bbox['bottom']
        )
    
    if type(rows) == str:
        rows = table_region.find_all(rows)

    if type(cols) == str:
        cols = table_region.find_all(cols)

    rows = sort_elems_by_dim(rows, dim='top')
    cols = sort_elems_by_dim(cols, dim='left')

    bbox = {
        'left': cols[0].bbox[0],
        'top': rows[0].bbox[1],
        'right': page.width,
        'bottom': page.height
    } | bbox

    rows = delineate_regions(page, bbox, rows, direction='row')
    cols = delineate_regions(page, bbox, cols, direction='col')

    df = pd.DataFrame([
        [intersection(page, [row, col]).extract_text() for col in cols]
        for row in rows
    ])

    if try_unfold:
        df = df_expand(df)

    return df